[
    {
        "question": "What is a Generator?",
        "answers": [
            "A generator is a function that produce a sequence of value lazily one at a time rather than storing them all in memory at once as a list. genrator uses yeild keyword to produce the value.",
            "def generator_new(n):\n    if n % 2==0:\n        yield n\nfor i in range(5):\n    gen=generator_new(i)\n    try:\n        print(next(gen))\n    except:\n        print(\"odd\")\n\nOutput: (no output)"
        ]
    },
    {
        "question": "what is iterator?",
        "answers": [
            "An iterator iterates over an object when it is used in a loop or when the next() function is called on it.",
            "my_list = [1, 2, 3]\nfor item in my_list:\n    print(item)\n\nOutput: (no output)"
        ]
    },
    {
        "question": "Deep copy vs shallow copy.",
        "answers": [
            "A shallow copy duplicates the values but keeps references to the same memory addresses, so changing the shallow copy\u2019s values affects the original object. In contrast, a deep copy duplicates the values to different memory addresses, so changes to the deep copy do not affect the original object.",
            "import copy\n\n# Original list\noriginal_list = [1, 2, [3, 4]]\n\n# Shallow copy\nshallow_copied_list = copy.copy(original_list)\n# Deep copy\ndeep_copied_list = copy.deepcopy(original_list)\n\n# Modify the nested list in the shallow copy\nshallow_copied_list[2][0] = 'shallow'\n\n# Modify the nested list in the deep copy\ndeep_copied_list[2][0] = 'deep'\n\nprint(\"Original list:\", original_list)\nprint(\"Shallow copied list:\", shallow_copied_list)\nprint(\"Deep copied list:\", deep_copied_list)\n\n"
        ]
    },
    {
        "question": "List vs Tuple?",
        "answers": [
            "List:\\n\u2022 Mutable: Can be modified after creation (e.g., add/remove elements).\\n\u2022 Memory: It's slower than tuple.\\n\u2022 Syntax: Square brackets [].\\n\u2022 Example: my_list = [1, 2, 3]\\n\\nTuple:\\n\u2022 Immutable: Cannot be modified after creation.\\n\u2022 Memory: It's faster than list.\\n\u2022 Syntax: Parentheses ().\\n\u2022 Example: my_tuple = (1, 2, 3)",
            ""
        ]
    },
    {
        "question": "Memory management in python:",
        "answers": [
            "Python Memory Management:\nPython uses two main types of memory: stack memory and heap memory.\n\nStack Memory:\nPurpose: Stack memory is used for static memory allocation. It stores local variables and function call information.\nCharacteristics: It operates in a Last-In-First-Out (LIFO) manner. When a function is called, a new stack frame is created to store its local variables and other information. Once the function returns, the stack frame is popped off, and the memory is reclaimed.\nUsage: Ideal for small, temporary data like integers and function calls.\nHeap Memory\nPurpose: Heap memory is used for dynamic memory allocation. It stores objects and data structures that need to persist beyond the scope of a single function call.\nCharacteristics: Unlike stack memory, heap memory is not organized in a specific order. It is managed by Python\u2019s memory manager and garbage collector.\nUsage: Suitable for larger collections of data, such as lists, dictionaries, and custom objects.",
            "\nReference Counting:\nMechanism: Python uses reference counting as its primary memory management technique. Each object maintains a count of how many references point to it.\nProcess: When an object\u2019s reference count drops to zero, it means the object is no longer in use, and the memory can be reclaimed.\nGarbage Collection:\nMechanism: Python\u2019s garbage collector automatically manages memory by reclaiming unused objects. It uses reference counting and cyclic garbage collection to identify and clean up unused data.\nProcess: For cyclic references, Python uses a cyclic garbage collector to detect and break these cycles.\nMemory Management Techniques\nMemory Pools:\nFunction: Python uses memory pools to manage small objects (up to 512 bytes). These pools are pre-allocated chunks of memory, divided into blocks that store objects of similar sizes.\nBenefit: This approach reduces memory fragmentation and improves allocation performance by reusing memory blocks when objects are deallocated.\nBlock Allocation:\nFunction: For larger objects (over 512 bytes), Python uses block allocation. This strategy allocates memory blocks directly from the heap.\nBenefit: It ensures efficient memory usage for large objects."
        ]
    },
    {
        "question": "What is class method and static method?",
        "answers": [
            "A static method in a class functions like a regular function and does not modify the class or instance state, nor does it take self or cls as parameters. In contrast, a class method takes cls as an argument, which refers to the class itself, allowing it to modify class-level state that applies across all instances.",
            "class MyClass:\n    class_variable = 0\n\n    def __init__(self, instance_variable):\n        self.instance_variable = instance_variable\n\n    @classmethod\n    def class_method(cls):\n        cls.class_variable += 1\n        print(f\"Class variable is now {cls.class_variable}\")\n\n    @staticmethod\n    def static_method():\n        print(\"This is a static method. It doesn't modify class or instance state.\")\n\n# Example usage\nobj1 = MyClass(1)\nobj2 = MyClass(2)\n\n# Calling class method\nMyClass.class_method()  # Output: Class variable is now 1\nobj1.class_method()     # Output: Class variable is now 2\n\n# Calling static method\nMyClass.static_method()  # Output: This is a static method. It doesn't modify class or instance state.\nobj1.static_method()     # Output: This is a static method. It doesn't modify class or instance state.\n\nOutput: Class variable is now 1\nClass variable is now 2\nThis is a static method. It doesn't modify class or instance state.\nThis is a static method. It doesn't modify class or instance state."
        ]
    },
    {
        "question": "What is a map function?",
        "answers": [
            "The map() function in Python is used to apply a given function to all items in an iterable (eg. a list) and returns an iterable map object. It takes a function in one or more iterables as arguments and applies the function to each corresponding element.",
            "numbers=[1,2,3,4]\nsquared = map(lambda x:x**2,numbers)\nresult = list(sqaured)\n\nError: name 'sqaured' is not defined"
        ]
    }
]
